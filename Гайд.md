# LEO-LANGUAGE
Простой гайд для начинающих, кто хотел бы узнать о языке LEO поподробнее и на простом языке.
**Руководство по языку программирования Leo**

**Статическая типизация**

Leo - это язык программирования со статической типизацией, что означает, что нам необходимо знать тип каждой переменной перед выполнением программы.

**Требуется явное указание типов**

В Leo не существует значений undefined или null. При присваивании новой переменной тип значения должен быть явно указан.

**Передача по значению**

Выражения в Leo всегда передаются по значению, что означает, что их значения всегда копируются, когда они используются в качестве входных данных для функций или в правой части операторов присваивания.

### **Типы данных и значения**

**Булевы значения**

Leo поддерживает традиционные булевы значения true или false. В явных операторах булевых значений требуется явный тип bool.

```leo
let b: bool = false;
```

**Целые числа**

Leo поддерживает знаковые целочисленные типы i8, i16, i32, i64, i128 и беззнаковые типы u8, u16, u32, u64, u128.

```leo
let b: u8 = 1u8;
```

Можно использовать подчеркивания `_` для разделения цифр в литералах целых чисел.

```leo
let b: u8 = 1_000_000u64;
```

**Элементы поля**

Leo поддерживает тип поля для элементов базового поля эллиптической кривой. Это беззнаковые целые числа, меньшие по модулю, чем модуль базового поля.

```leo
let a: field = 0field;
let b: field = 8444461749428370424248824938781546531375899335154063827935233455917409239040field;
```

**Элементы группы**

Множество аффинных точек на эллиптической кривой формирует группу. Leo поддерживает подгруппу группы, сгенерированную точкой-генератором, как примитивный тип данных.

```leo
let a: group = 0group; // точка с x-координатой 0, (0, 1)
let b: group = 1540945439182663264862696551825005342995406165131907382295858612069623286213group; // генераторная точка
```

Можно получить вышеупомянутую генераторную точку с помощью константы, связанной с типом группы.

```leo
let g: group = group::GEN; // генератор группы
```

**Элементы скаляра**

Leo поддерживает тип скаляра для элементов скалярного поля, определенного подгруппой эллиптической кривой. Это беззнаковые целые числа, меньшие по модулю, чем модуль скалярного поля.

```leo
let a: scalar = 0scalar;
let b: scalar = 2111115437357092606062206234695386632838870926408408195193685246394721360382scalar;
```

**Адреса**

Адреса определены для обеспечения оптимизированных компилятором процедур для разбора и работы с адресами. Эти семантики будут сопровождаться стандартной библиотекой в будущих версиях.

```leo
let receiver: address = aleo1ezamst4pjgj9zfxqq0fwfj8a4cjuqndmasgata3hggzqygggnyfq6kmyd4;
```

**Подписи**

Aleo использует схему подписей Schnorr для подписи сообщений закрытым ключом Aleo. Подписи в Leo имеют свой собственный тип и могут быть объявлены как литералы.

```leo
program test.aleo {
    struct foo {
        a: u8,
        b: scalar
    }

    transition verify_field(s: signature, a: address, v: field) {
        let first: bool = signature::verify(s, a, v);
        let second: bool = s.verify(a, v);
        assert_eq(first, second);
    }

    transition verify_foo(s: signature, a: address, v: foo) {
        let first: bool = signature::verify(s, a, v);
        let second: bool = s.verify(a, v);
        assert_eq(first, second);
    }
}
```

### **Структура программы Leo**

Программа Leo состоит из объявлений в области программы, импортов, переходных функций, вспомогательных функций, структур, записей, отображений и функций завершения. Объявления могут быть доступны только в пределах файла программы. Если вам нужно использовать объявление из другого файла Leo, его нужно импортировать.

#### **Область программы**

Область программы в Leo - это совокупность кода (функций) и данных (типов), которые находятся под программным идентификатором на блокчейне Aleo.

```leo
import foo.leo;
```

**Примечание:** Первый символ имени должен быть в нижнем регистре. Имя может содержать строчные буквы, цифры и подчеркивания. В настоящее время поддерживается только доменная зона aleo.

```leo
program hello.aleo; // валидно

program Foo.aleo;   // невалидно
program baR.aleo;   // невалидно
program 0

bar.aleo;   // невалидно
```

#### **Импорт**

Импортирование позволяет вам использовать определения из других файлов программы Leo в текущем файле. Это делается с помощью ключевого слова `import`.

```leo
import foo.leo;

let a: foo::MyStruct = foo::MyStruct{a: 42, b: 3.14};
```

#### **Переходные функции**

Переходные функции определяют поведение программы. Они могут быть вызваны извне программы Leo. Каждая переходная функция должна иметь один аргумент типа `transient`.

```leo
transition transfer(tx: transient) {
    // код для перевода средств
}
```

#### **Вспомогательные функции**

Вспомогательные функции являются вспомогательными функциями, которые могут быть вызваны изнутри программы. Они помогают вам избежать дублирования кода.

```leo
helper function add(a: u64, b: u64): u64 {
    return a + b;
}
```

#### **Структуры**

Структуры в Leo представляют собой набор именованных полей, каждое из которых имеет свой тип данных.

```leo
struct Point {
    x: u64,
    y: u64,
}

let p: Point = Point{x: 1, y: 2};
```

#### **Записи**

Записи в Leo - это упорядоченные наборы значений фиксированной длины.

```leo
record Point(u64, u64);

let p: Point = Point(1, 2);
```

#### **Отображения**

Отображения в Leo - это ассоциативные массивы, которые могут хранить множество ключей и соответствующих им значений.

```leo
map<u64, u64> numbers = {1: 10, 2: 20, 3: 30};
let value: u64 = numbers[2];
```

#### **Функции завершения**

Функции завершения выполняются при завершении выполнения программы и могут использоваться для освобождения ресурсов.

```leo
completion function cleanup() {
    // код очистки ресурсов
}
```

### **Управление потоком**

**Условные операторы**

Leo поддерживает условные операторы `if`, `else if` и `else`, которые позволяют вам делать ветвление в вашем коде.

```leo
if condition {
    // код, который выполнится, если условие истинно
} else if another_condition {
    // код, который выполнится, если другое условие истинно
} else {
    // код, который выполнится, если ни одно из условий не истинно
}
```

**Циклы**

Leo поддерживает циклы `while` и `for`.

```leo
let i: u64 = 0;
while i < 10 {
    // код, который выполнится в каждой итерации цикла
    i = i + 1;
}

for i in 0..10 {
    // код, который выполнится в каждой итерации цикла
}
```

**Исключения**

Leo пока не поддерживает механизм исключений. Однако это может быть добавлено в будущих версиях языка.

### **Стандартная библиотека**

Leo поставляется с набором стандартных библиотечных функций, которые предоставляют полезные функции для работы с типами данных, работой сети и другими задачами. Стандартная библиотека является постоянно расширяемой и обновляется с каждым выпуском новой версии языка.

```leo
import std::math;

let result: u64 = math::add(10, 20);
```

### **Компиляция и выполнение**

Leo-программы компилируются в исполняемый код с помощью компилятора Aleo. После компиляции программы ее можно развернуть на блокчейне Aleo и выполнить.

```sh
aleoc hello.aleo
```

**Примечание:** Для компиляции программы требуется наличие установленного компилятора Aleo на вашем компьютере. Компилятор Aleo может быть загружен с [официального сайта Aleo](https://aleo.org/).

Это основы языка программирования Leo. Помните, что Leo - это активно развивающийся язык, и новые возможности и изменения могут быть внесены в последующих версиях языка.
